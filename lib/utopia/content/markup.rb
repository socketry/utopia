# frozen_string_literal: true

# Released under the MIT License.
# Copyright, 2009-2022, by Samuel Williams.

require 'xrb/parsers'
require 'xrb/entities'
require 'xrb/strings'
require 'xrb/tag'

module Utopia
	class Content
		Tag = XRB::Tag
		
		# A hash which forces all keys to be symbols and fails with KeyError when strings are used.
		class SymbolicHash < Hash
			def [] key
				raise KeyError.new("attribute #{key} is a string, prefer a symbol") if key.is_a? String
				super key.to_sym
			end
			
			def []= key, value
				super key.to_sym, value
			end
			
			def fetch(key, *arguments, &block)
				key = key.to_sym
				
				super
			end
			
			def include? key
				key = key.to_sym
				
				super
			end
		end
		
		# Provides a high level interface for parsing markup.
		class MarkupParser
			# A tag generated by parsing markup.
			class ParsedTag
				def initialize(name, offset)
					@offset = offset
					@tag = Tag.new(name, false, SymbolicHash.new)
				end
				
				attr :tag
				attr :offset
				
				def to_s
					"<#{@tag.name}#{@tag.attributes.empty? ? '' : ' ...'}>"
				end
			end
			
			# The name of a closing tag fails to match up with the corresponding opening tag.
			class UnbalancedTagError < StandardError
				def initialize(buffer, opening_tag, closing_tag = nil)
					@buffer = buffer
					@opening_tag = opening_tag
					@closing_tag = closing_tag
				end

				attr :buffer
				attr :opening_tag
				attr :closing_tag
				
				def start_location
					XRB::Location.new(@buffer.read, opening_tag.offset)
				end
				
				def end_location
					if closing_tag and closing_tag.respond_to? :offset
						XRB::Location.new(@buffer.read, closing_tag.offset)
					end
				end
				
				def to_s
					if @closing_tag
						"#{start_location}: #{@opening_tag} was not closed!"
					else
						"#{start_location}: #{@opening_tag} was closed by #{@closing_tag}!"
					end
				end
			end
			
			def self.parse(buffer, delegate, entities = XRB::Entities::HTML5)
				# This is for compatibility with the existing API which passes in a string:
				buffer = XRB::Buffer(buffer)
				
				self.new(buffer, delegate, entities).parse!
			end
			
			def initialize(buffer, delegate, entities = XRB::Entities::HTML5)
				@buffer = buffer
				
				@delegate = delegate
				@entities = entities
				
				@current = nil
				@stack = []
			end
			
			def parse!
				XRB::Parsers.parse_markup(@buffer, self, @entities)
				
				if tag = @stack.pop
					raise UnbalancedTagError.new(@buffer, tag)
				end
			end

			def open_tag_begin(name, offset)
				@current = ParsedTag.new(name, offset)
			end

			def attribute(key, value)
				@current.tag.attributes[key] = value
			end

			def open_tag_end(self_closing)
				if self_closing
					@current.tag.closed = true
					@delegate.tag_complete(@current.tag)
				else
					@stack << @current
					@delegate.tag_begin(@current.tag)
				end
				
				@current = nil
			end

			def close_tag(name, offset)
				@current = @stack.pop
				tag = @current.tag
				
				if tag.name != name
					raise UnbalancedTagError.new(@buffer, @current, ParsedTag.new(name, offset))
				end
				
				@delegate.tag_end(tag)
			end
			
			def doctype(string)
				@delegate.write(string)
			end

			def comment(string)
				@delegate.write(string)
			end

			def instruction(string)
				@delegate.write(string)
			end

			def cdata(string)
				@delegate.write(string)
			end

			def text(string)
				@delegate.text(string)
			end
		end
	end
end

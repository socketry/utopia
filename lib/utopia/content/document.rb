# frozen_string_literal: true

# Released under the MIT License.
# Copyright, 2015-2025, by Samuel Williams.

require_relative "links"
require_relative "response"
require_relative "markup"
require_relative "builder"

module Utopia
	module Content
		# This error is raised if a tag doesn't match up when parsing.
		class UnbalancedTagError < StandardError
			def initialize(tag)
				@tag = tag
				
				super "Unbalanced tag #{tag.name}"
			end
			
			attr :tag
		end
		
		# A single request through content middleware. We use a struct to hide instance varibles since we instance_exec within this context.
		class Document < Response
			def self.render(node, request, attributes)
				self.new(request, attributes).render!(node, attributes)
			end
			
			def initialize(request, attributes = {})
				@request = request
				
				@attributes = attributes
				
				@first = nil
				@current = nil
				@end_tags = []
				
				super()
			end
			
			# @returns [Path] The original request path, if known.
			def request_path
				Path[request.env["REQUEST_PATH"]]
			end
			
			protected def current_base_uri_path
				self.current.node.uri_path
			end
			
			# Compute the relative path from the curent base uri (e.g. the node being rendered) to the request uri. This path can be used to ensure resources are loaded relative to a given path.
			#
			# | Relative To   | Request Path           | Base URI     |
			# |---------------|------------------------|--------------|
			# | "/page"       | "/index"               | ""           |
			# | "/blog/entry" | "/blog/2025/05/my-cat" | "../.."      |
			#
			# @returns [String] the base uri for the current page.
			def base_uri(relative_to = self.current_base_uri_path)
				Path[relative_to].dirname.shortest_path(request_path)
			end
			
			def [] key
				@attributes[key]
			end
			
			def []= key, value
				@attributes[key] = value
			end
			
			def render!(node, attributes)
				@body << render_node(node, attributes)
				
				return self
			end
			
			# A helper method for accessing controller variables from view:
			def controller
				@controller ||= Utopia::Controller[request]
			end
			
			def localization
				@localization ||= Utopia::Localization[request]
			end
			
			def parse_markup(markup)
				MarkupParser.parse(markup, self)
			end
			
			# The Rack::Request for this document.
			attr :request
			
			# Per-document global attributes.
			attr :attributes
			
			# The current state, represents a list from outer to inner most tag by traversing {State#parent}.
			# At any point in parsing markup, this is a list of the inner most tag,
			# then the next outer tag, etc.
			attr :current
			
			# The first {State} generated by rendering this document. It contains useful information
			# regarding the node and uri used to access the resource.
			attr :first
			
			# End tags represents a list of execution order. This is the order that end tags
			# have appeared when evaluating nodes.
			attr :end_tags
			
			def tag(name, attributes = {})
				# If we provide a block which can give inner data, we are not self-closing.
				tag = Tag.new(name, !block_given?, attributes)
				
				if block_given?
					node = tag_begin(tag)
					yield node
					tag_end(tag)
				else
					tag_complete(tag, node)
				end
			end
			
			def tag_complete(tag, node = nil)
				node ||= lookup_tag(tag)
				
				if node
					tag_begin(tag, node)
					tag_end(tag)
				else
					@current.tag_complete(tag)
				end
			end
			
			def tag_begin(tag, node = nil)
				node ||= lookup_tag(tag)
				
				if node
					@current = Builder.new(@current, tag, node, tag.to_hash, indent: false)
					
					node.tag_begin(self, @current) if node.respond_to?(:tag_begin)
					
					return node
				end
				
				# raise ArgumentError.new("tag_begin: #{tag} is tag.self_closed?") if tag.self_closed?
				
				@current.tag_begin(tag)
				
				return nil
			end
			
			def write(string)
				@current.write(string)
			end
			
			alias cdata write
			
			def text(string)
				@current.text(string)
			end
			
			def tag_end(tag = nil)
				# Determine if the current state contains tags that need to be completed, or if the state itself is finished.
				if @current.empty?
					if node = @current.node
						node.tag_end(self, @current) if node.respond_to?(:tag_end)
					end
					
					@end_tags << @current
					buffer = @current.call(self)
					
					@current = @current.parent
					@end_tags.pop
					
					@current.write(buffer) if @current
					
					return buffer
				else
					# raise ArgumentError.new("tag_begin: #{tag} is tag.self_closed?") if tag.self_closed?
					@current.tag_end(tag)
				end
				
				return nil
			end
			
			def render_node(node, attributes = {})
				@current = Builder.new(@current, nil, node, attributes, indent: false)
				
				# We keep track of the first thing rendered by this document.
				@first ||= @current
				
				# This returns the content of rendering the tag:
				return tag_end
			end
			
			# Maps a tag to a node instance by asking the current node to lookup the tag name. This function is called for each tag and thus heavily affects performance.
			# @return [Node] The node for the given tag.
			def lookup_tag(tag)
				# result = tag
				# 
				# # This loop works from inner to outer tags, and updates the tag we are currently searching for based on any overrides:
				# @begin_tags.reverse_each do |state|
				# 	result = state.lookup(result)
				# 	
				# 	return result if result.is_a?(Node)
				# end
				
				# This loop looks up a tag by asking the most embedded node to look it up based on tag name. This almost always only evaluates the top state:
				@end_tags.reverse_each do |state|
					return state.node.lookup_tag(tag) if state.node.respond_to?(:lookup_tag)
				end
				
				return nil
			end
			
			# Lookup a node with the given path relative to the current node.
			# @return [Node] The node if could be found.
			def lookup_node(path)
				@end_tags.reverse_each do |state|
					return state.node.lookup_node(path) if state.node.respond_to?(:lookup_node)
				end
			end
			
			# The content of the node
			def content
				@end_tags.last.content
			end
			
			def parent
				@end_tags[-2]
			end
		end
	end
end
